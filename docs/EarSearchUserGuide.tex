\documentclass[11pt]{article}
\usepackage{times, graphicx,float, multicol}
\usepackage[rflt]{floatflt}
\usepackage{hyperref}
\usepackage{algorithm,algorithmic}
\usepackage{multirow}

\setlength{\textwidth}{6.5in}
\setlength{\textheight}{9.0in}
\setlength{\topmargin}{-.5in}
\setlength{\oddsidemargin}{-.0600in}
\setlength{\evensidemargin}{.0625in}

\newcommand{\secref}[1]{Section~\ref{#1}}

\newcommand{\doublespace}{\baselineskip0.34truein}
\newcommand{\singlespace}{\baselineskip0.16truein}
\newcommand{\midspace}{\baselineskip0.24truein}
\newcommand{\midplusspace}{\baselineskip0.26truein}


\title{EarSearch User Guide\\ {\large Version 1.0}}

\author{Derrick Stolee \\ 
	University of Nebraska-Lincoln\\ 
	\texttt{s-dstolee1@math.unl.edu}
       }
       
\begin{document}

\maketitle
\vspace{-.3in}
\begin{abstract}
	The Ear Search program implements isomorph-free generation
		of 2-connected graphs by ear augmentations.
	This document describes the interfaces used for customized
		searches, as well as describes three example searches:
		unique saturation, edge reconstruction, and 
		extremal graphs with a fixed number of perfect matchings.
\end{abstract}

\section{Introduction}
\label{sec:Introduction}

The EarSearch library implements the generation algorithm of
	\cite{IsomorphFreeGen} to generate families of 2-connected graphs.
It is based on the TreeSearch library \cite{TreeSearch}.
The class \texttt{EarSearchManager} extends the class \texttt{SearchManager}
	and manages the search tree,
	using ear augmentations to generate children.
It automates the canonical deletion selection in order
	to remove isomorphs.
	

\section{Data Management}


\subsection{Graphs}

Graphs are stored 
	using the \texttt{sparsegraph} structure 
	from the \texttt{nauty} library.

During the course of computation, these graphs are modified using edge and vertex deletions.
To delete the $i$th vertex, set the \texttt{v} array to $-1$ in the $i$th position.
To delete the edge between the $i$ and $j$ vertices,
	set the \texttt{e} array to $-1$ in two places:
	in the list of neighbors for $i$ where $j$ was listed
	and in the list of neighbors for $j$ where $i$ was listed.
To place the vertices or edges back, place the previous values into those places.



\subsection{Augmentations and Labels}

The labels for each augmentation use two 32-bit integers.
The first is the order of the augmented ear.
The second is the index of the pair orbit which is used for
	the endpoints of the ear.

\subsection{\texttt{EarNode}}

Each level of the search tree is stored in a stack, where all data is stored in
	an \texttt{EarNode} object.
All of the members of \texttt{EarNode} are public, in order to easily add data
	structures and flags that are necessary for each application.
All pointers are initialized to $0$ in the constructor and
	are checked to be non-zero before freeing up any memory in the destructor.

The core data necessary for \texttt{EarSearchManager} is stored in 
	the following members:
	
\begin{itemize}
	\item ear\_length -- the length of the augmented ear.
	 

	\item ear -- the byte-array description of the augmented ear.
	 

	\item num\_ears -- the number of ears in the graph.
	 
	\item ear\_list -- the list of ears in the graph (-1 terminated).
	 

	\item graph -- the graph at this node.
	 
	\item max\_verts -- the maximum number of vertices in
	 all supergraphs. Default to max\_n from \texttt{EarSearchManager}.
	 

	\item 
	 reconstructible -- TRUE if detectably reconstructible
	 
	\item numPairOrbits -- the number of pair orbits for this graph.
	 
	 
	\item orbitList -- the list of orbits, in a an array of arrays.
		Each array \texttt{orbitList[i]} contains pair-indices for
			pairs in orbit and is terminated by \texttt{-1}.

	\item canonicalLabels -- the canonical labeling of the graph, 
		stored as an integer array of values for each vertex

	\item solution\_data -- the data of a solution on this node.
	 

	\item violatingPairs -- A set of pair indices which cannot be endpoints of an ear.
	 
\end{itemize}


\section{Pruning}

The interface \texttt{PruningAlgorithm} has an abstract method for
	pruning nodes of the search tree.
The method \texttt{checkPrune} takes two \texttt{EarNode} objects:
	one for the parent and another for the child.
Using this data, the method decides if no solution exists by augmenting
	beyond the child node.
Since the pruning algorithm is called before the canonical deletion algorithm,
	this can also remove nodes which cannot possibly be canonical augmentations.

\section{Canonical Deletion}

The interface \texttt{EarDeletionAlgorithm} has 
	an abstract method for finding a canonical ear deletion.
The method \texttt{getCanonical} takes two \texttt{EarNode} 
	objects for the parent and child
	and returns the array corresponding to the canonical ear.
The \texttt{EarSearchManager} will determine if this
	canonical ear is in orbit with the augmented ear.

\section{Solutions}

The interface \texttt{SolutionChecker} is an abstract class
	which contains methods for finding solutions given
	a search node, storing the solution data, reporting
	on these solutions, and reporting application-specific
	statistics.
	
The method \texttt{isSolution} takes the parent, child, and depth
	and reports if there is a solution at the child node.
It returns a non-null string if and only if there is a solution,
	and that string is a buffer containing the solution data.
This buffer will be deallocated with \texttt{free()} by 
	the \texttt{EarSearchManager}.

The method \texttt{writeStatisticsData()}
	returns a string of statistics (using the TreeSearch format)
	to be reported at the end of a job.



\section{Example 0: 2-Connected Graphs}




\section{Example 1: Unique Saturation}

\subsection{Application-Specific Data}

\begin{itemize}
	\item adj\_matrix\_data -- Data on the (directed) edges.
		For unique saturation, this gives -1 for edges, and 
			for non-edges counts the number of copies of $H$
			given by adding that edge.
		Values are in $\{0,1,2\}$, since when $2$ is 
			listed, then there are too many copies of $H$.

	\item any\_adj\_zero -- A boolean flag: are any of the cells in adj\_matrix\_data zero?
		

	\item any\_adj\_two -- A boolean flag:  are any of the cells in adj\_matrix\_data at least two?
	
	\item dom\_vert -- A boolean flag: is there a dominating vertex?

	\item copy\_of\_H -- A boolean flag: is there a copy of H?

\end{itemize}



\section{Example 2: Edge Reconstruction}

\subsection{Application-Specific Data}

\begin{itemize}
	
	\item child\_data -- the GraphData objects for immediate children, used for pairwise comparison.
	
	\item num\_child\_data -- the number of GraphData objects currently filling the data.
	\item size\_child\_data -- the number of pointers currently allocated.
\end{itemize}




\section{Example 3: $p$-Extremal Graphs}

This problem is investigated in \cite{pExtremal}.
See \cite{DudekSchmitt} and \cite{HSWY} for background on this problem.

\subsection{Application-Specific Data}

\begin{itemize}

	\item extendable -- A boolean flag: is the graph 1-extendable?

	\item numMatchings -- The number of perfect matchings for this graph.

	\item barriers -- The list of barriers of the graph, given as an array of Sets.

	\item num\_barriers -- the number of barriers in the graph.

\end{itemize}

\subsection{Perfect Matching Algorithms}

\begin{algorithm}[h]
	\caption{\label{alg:countpm}CountPM($G, P$)}
	\begin{algorithmic}
		\STATE
	\end{algorithmic}
\end{algorithm}

\begin{algorithm}[h]
	\caption{\label{alg:is1Extendable}is1Extendable($H$)}
	\begin{algorithmic}
		\STATE
	\end{algorithmic}
\end{algorithm}

\begin{algorithm}[h]
	\caption{\label{alg:maximalSupergraphs}maximalSupergraphs($H$)}
	\begin{algorithmic}
		\STATE
	\end{algorithmic}
\end{algorithm}





\begin{thebibliography}{9}
	\bibitem{DudekSchmitt} A. Dudek and J. Schmidt.
		On extremal graphs with a constant number of 1-factors.
		submitted. 2010.

	\bibitem{HRnauty} S. G. Hartke and A. J. Radcliffe. 
		MckayÕs canonical graph labeling algorithm. 
		In {\it Communicating Mathematics}, 
		volume 479 of {\it Contemporary Mathematics}, 99Ð111. 2009.
		
	\bibitem{HSWY} S. G. Hartke, D. Stolee, D. B. West, and M. Yancey.
		On extremal graphs with a fixed number of perfect matchings.
		in preparation. 2011.

	\bibitem{McKayReconstruct} B. D. McKay. Small graphs are reconstructible. 
		{\it Australas. J. Combin.}, 15:123Ð 126, 1997.

	\bibitem{McKayGenerate} B. D. McKay, 
		Isomorph-free exhaustive generation
		{\it J. Algorithms}, 26(6):306-324. 1998.
		
	\bibitem{McKayNauty} B. D. McKay,
		nauty user's guide (version 2.4)
		Dept. Computer Science, Astral. Nat. Univ., 2006.
	
	\bibitem{IsomorphFreeGen} D. Stolee, 
		Isomorph-free generation of 2-connected graphs with applications,
		in preparation, 2011.
		
	\bibitem{pExtremal} D. Stolee,
		Generating $p$-extremal graphs,
		in preparation, 2011.
		
	\bibitem{TreeSearch} D. Stolee,
		TreeSearch user guide,
		available at 
		\href{http://www.github.com/derrickstolee/TreeSearch/}{http://www.github.com/derrickstolee/TreeSearch/}
		2011.
\end{thebibliography}

\end{document}
